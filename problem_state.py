# This file is generated by generate_problem_state.py.

from src.problems.tsp.components import Solution


import numpy as np
from scipy import stats

def get_instance_problem_state(instance_data: dict) -> dict:
    """Extract instance problem state from instance data.

    Args:
        instance_data (dict): The dictionary contains the instance data with:
            - node_num (int): The total number of nodes in the problem.
            - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.

    Returns:
        dict: The dictionary contains the instance problem state with:
            - num_cities (int): The number of cities/nodes in the instance.
            - avg_distance (float): The average of all unique pairwise distances.
            - std_distance (float): The standard deviation of all unique pairwise distances.
            - min_distance (float): The minimum distance between any two nodes.
            - max_distance (float): The maximum distance between any two nodes.
            - avg_nearest_neighbor_dist (float): The average distance from each node to its nearest neighbor.
            - centroid_std (float): The standard deviation of distances from each node to the centroid of all nodes.
            - distance_matrix_skew (float): The skewness of the distance distribution.
            - distance_matrix_kurtosis (float): The kurtosis of the distance distribution.
    """
    # Extract the distance matrix from instance_data
    distance_matrix = instance_data['distance_matrix']
    node_num = instance_data['node_num']
    
    # Get all unique pairwise distances (excluding diagonal zeros)
    # Use numpy.triu_indices to get upper triangle indices without the diagonal (k=1)
    upper_triangle_indices = np.triu_indices_from(distance_matrix, k=1)
    all_distances = distance_matrix[upper_triangle_indices]
    
    # Calculate basic statistics
    num_cities = node_num
    avg_distance = np.mean(all_distances)
    std_distance = np.std(all_distances)
    min_distance = np.min(all_distances)
    max_distance = np.max(all_distances)
    
    # Calculate average nearest neighbor distance
    # For each node, find the minimum distance to any other node (excluding self-distance)
    # Create a copy of distance matrix and set diagonal to a large value to exclude self
    dist_matrix_no_self = distance_matrix.copy()
    np.fill_diagonal(dist_matrix_no_self, np.inf)
    nearest_neighbor_dists = np.min(dist_matrix_no_self, axis=1)
    avg_nearest_neighbor_dist = np.mean(nearest_neighbor_dists)
    
    # Calculate centroid standard deviation
    # Since we don't have coordinates, we approximate the centroid using the distance matrix
    # We use the concept of "distance centroid" - the node with minimum total distance to all others
    total_distances = np.sum(distance_matrix, axis=1)
    centroid_node = np.argmin(total_distances)
    distances_to_centroid = distance_matrix[centroid_node]
    centroid_std = np.std(distances_to_centroid)
    
    # Calculate skewness and kurtosis of distance distribution
    distance_matrix_skew = stats.skew(all_distances)
    distance_matrix_kurtosis = stats.kurtosis(all_distances)
    
    # Return all calculated problem states as a dictionary
    return {
        'num_cities': num_cities,
        'avg_distance': float(avg_distance),
        'std_distance': float(std_distance),
        'min_distance': float(min_distance),
        'max_distance': float(max_distance),
        'avg_nearest_neighbor_dist': float(avg_nearest_neighbor_dist),
        'centroid_std': float(centroid_std),
        'distance_matrix_skew': float(distance_matrix_skew),
        'distance_matrix_kurtosis': float(distance_matrix_kurtosis)
    }

from src.problems.tsp.components import Solution
import numpy as np
from scipy import spatial

def get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:
    """Extract solution problem state from instance data and current solution.

    Args:
        instance_data (dict): The dictionary contains the instance data with:
            - node_num (int): The total number of nodes in the problem.
            - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.
        solution (Solution): The current solution instance with tour attribute.

    Returns:
        dict: The dictionary contains the solution problem state with:
            - current_tour_length (float): Total length of the current tour (complete or partial)
            - percent_complete (float): Percentage of nodes visited in the tour
            - avg_edge_length_current (float): Average length of edges in the current tour
            - std_edge_length_current (float): Standard deviation of edge lengths in current tour
            - current_to_optimal_ratio (float): Ratio of current tour length to estimated optimal
            - unvisited_nodes_count (int): Number of nodes not yet visited
            - avg_distance_to_unvisited (float): Average minimum distance from visited to unvisited nodes
            - connectivity_quality (float): Quality of connection from last node to unvisited nodes
            - cluster_cohesion (float): Ratio of intra-cluster vs inter-cluster edges
            - path_compactness (float): Spatial compactness of the current path
    """
    # Extract data from inputs
    distance_matrix = instance_data['distance_matrix']
    total_nodes = instance_data['node_num']
    current_tour = solution.tour
    visited_count = len(current_tour)
    
    # Calculate basic tour metrics
    current_length = 0.0
    edge_lengths = []
    
    # Calculate length of constructed path (for complete or partial tour)
    for i in range(len(current_tour) - 1):
        edge_length = distance_matrix[current_tour[i], current_tour[i + 1]]
        current_length += edge_length
        edge_lengths.append(edge_length)
    
    # If tour is complete, add return to start edge
    if visited_count == total_nodes and visited_count > 1:
        return_edge = distance_matrix[current_tour[-1], current_tour[0]]
        current_length += return_edge
        edge_lengths.append(return_edge)
    
    # Calculate percentage complete
    percent_complete = visited_count / total_nodes if total_nodes > 0 else 0.0
    
    # Calculate edge statistics
    avg_edge_length = np.mean(edge_lengths) if edge_lengths else 0.0
    std_edge_length = np.std(edge_lengths) if len(edge_lengths) > 1 else 0.0
    
    # Estimate optimal tour length using nearest neighbor heuristic
    def estimate_optimal_tour_length():
        if total_nodes == 0:
            return 1.0  # Avoid division by zero
        
        # Simple nearest neighbor estimation
        unvisited = set(range(total_nodes))
        current = 0
        tour_length = 0.0
        unvisited.remove(current)
        
        while unvisited:
            # Find nearest unvisited neighbor
            nearest = min(unvisited, key=lambda x: distance_matrix[current, x])
            tour_length += distance_matrix[current, nearest]
            current = nearest
            unvisited.remove(current)
        
        # Return to start
        tour_length += distance_matrix[current, 0]
        return tour_length
    
    optimal_estimate = estimate_optimal_tour_length()
    current_to_optimal_ratio = current_length / optimal_estimate if optimal_estimate > 0 else float('inf')
    
    # Calculate unvisited nodes metrics
    unvisited_nodes_count = total_nodes - visited_count
    visited_set = set(current_tour)
    unvisited_set = set(range(total_nodes)) - visited_set
    
    # Calculate average minimum distance from visited to unvisited nodes
    if unvisited_set and visited_set:
        min_distances = []
        for visited_node in visited_set:
            min_dist_to_unvisited = min(distance_matrix[visited_node, u] for u in unvisited_set)
            min_distances.append(min_dist_to_unvisited)
        avg_distance_to_unvisited = np.mean(min_distances)
    else:
        avg_distance_to_unvisited = 0.0
    
    # Calculate connectivity quality from last node
    if current_tour and unvisited_set:
        last_node = current_tour[-1]
        min_connection = min(distance_matrix[last_node, u] for u in unvisited_set)
        avg_distance = np.mean(distance_matrix)
        connectivity_quality = min_connection / avg_distance if avg_distance > 0 else 0.0
    else:
        connectivity_quality = 0.0
    
    # For cluster cohesion and path compactness, we need spatial coordinates
    # Since we only have distance matrix, we'll approximate these metrics
    cluster_cohesion = 0.5  # Placeholder - requires coordinate data
    path_compactness = 0.5  # Placeholder - requires coordinate data
    
    return {
        'current_tour_length': float(current_length),
        'percent_complete': float(percent_complete),
        'avg_edge_length_current': float(avg_edge_length),
        'std_edge_length_current': float(std_edge_length),
        'current_to_optimal_ratio': float(current_to_optimal_ratio),
        'unvisited_nodes_count': int(unvisited_nodes_count),
        'avg_distance_to_unvisited': float(avg_distance_to_unvisited),
        'connectivity_quality': float(connectivity_quality),
        'cluster_cohesion': float(cluster_cohesion),
        'path_compactness': float(path_compactness)
    }

def get_observation_problem_state(solution_problem_state: dict) -> dict:
    """Extract core problem state as observation.

    Args:
        solution_problem_state (dict): The dictionary contains the solution problem state.

    Returns:
        dict: The dictionary contains the core problem state with:
            - current_tour_length (float): Total length of the current tour
            - percent_complete (float): Percentage of nodes visited in the tour
            - avg_edge_length_current (float): Average length of edges in the current tour
            - std_edge_length_current (float): Standard deviation of edge lengths in current tour
            - current_to_optimal_ratio (float): Ratio of current tour length to estimated optimal
            - unvisited_nodes_count (int): Number of nodes not yet visited
            - avg_distance_to_unvisited (float): Average minimum distance from visited to unvisited nodes
            - connectivity_quality (float): Quality of connection from last node to unvisited nodes
    """
    return {
        "current_tour_length": solution_problem_state["current_tour_length"],
        "percent_complete": solution_problem_state["percent_complete"],
        "avg_edge_length_current": solution_problem_state["avg_edge_length_current"],
        "std_edge_length_current": solution_problem_state["std_edge_length_current"],
        "current_to_optimal_ratio": solution_problem_state["current_to_optimal_ratio"],
        "unvisited_nodes_count": solution_problem_state["unvisited_nodes_count"],
        "avg_distance_to_unvisited": solution_problem_state["avg_distance_to_unvisited"],
        "connectivity_quality": solution_problem_state["connectivity_quality"]
    }